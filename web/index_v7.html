<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prefix‑Sum CPU + WebGPU Vector Renderer (AA, Joins/Caps, Text, SVG)</title>
  <style>
    :root { --bg:#0f1220; --panel:#12162b; --ink:#e7e9ef; --line:#232849; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--ink);
      font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,sans-serif; }
    header { padding:12px 16px; background:#151934; position:sticky; top:0; z-index:5;
      box-shadow:0 2px 8px rgba(0,0,0,.25); }
    header h1 { margin:0; font-size:16px; font-weight:600; }
    .row { display:grid; grid-template-columns:360px 1fr; gap:16px; padding:16px; }
    .panel { background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:12px; position:relative; }
    label { display:flex; align-items:center; gap:8px; margin:6px 0; }
    input[type="range"] { width:100%; }
    select, button { background:#2a3160; color:#fff; border:1px solid #3b4282;
      border-radius:10px; padding:6px 8px; }
    button { cursor:pointer; }
    button:hover { filter:brightness(1.06); }
    .mono { font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; }
    .small { font-size:12px; opacity:.9; }
    canvas { background:#0b0e1d; border:1px solid var(--line); border-radius:12px; width:100%; height:auto; image-rendering:pixelated; }
    .row2 { display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-top:8px; }
    .stat { background:#0e1330; border:1px dashed #2e3569; border-radius:10px; padding:8px; text-align:center; }
    dialog { border:1px solid #3b4282; border-radius:10px; background:#0b0e1d; color:#e7e9ef; max-width:860px; }
    dialog::backdrop{ background: rgba(0,0,0,.45); }
  </style>
</head>
<body>
  <header><h1>Prefix‑Sum CPU + WebGPU Vector Renderer → AA + Joins/Caps + Text + SVG</h1></header>

  <div class="row">
    <div class="panel">
      <div><strong>Scene controls</strong></div>

      <label>Renderer
        <select id="renderer">
          <option value="auto" selected>Auto (WebGPU if available)</option>
          <option value="webgpu">WebGPU</option>
          <option value="cpu">CPU (Workers)</option>
        </select>
      </label>

      <label>Canvas Size
        <select id="size">
          <option value="800x600">800 × 600</option>
          <option value="1024x768">1024 × 768</option>
          <option value="1280x720">1280 × 720</option>
          <option value="1920x1080">1920 × 1080</option>
        </select>
      </label>

      <label>Tile Size (px)
        <input id="tile" type="range" min="16" max="128" value="64" step="16" />
        <span id="tileVal" class="mono small">64</span>
      </label>

      <label>Workers (CPU)
        <input id="workers" type="range" min="1" max="16" value="4" />
        <span id="workersVal" class="mono small">4</span>
      </label>

      <label>Stroke Width
        <input id="stroke" type="range" min="1" max="40" value="10" />
        <span id="strokeVal" class="mono small">10</span>
      </label>

      <label>Join
        <select id="join">
          <option value="round" selected>round</option>
          <option value="bevel">bevel</option>
          <option value="miter">miter</option>
        </select>
      </label>

      <label>Cap
        <select id="cap">
          <option value="round" selected>round</option>
          <option value="butt">butt</option>
          <option value="square">square</option>
        </select>
      </label>

      <label>Miter Limit
        <input id="miter" type="range" min="1" max="10" step="0.25" value="4" />
        <span id="miterVal" class="mono small">4</span>
      </label>

      <label>AA (supersample)
        <select id="aa">
          <option value="1">1× (off)</option>
          <option value="2" selected>2×</option>
          <option value="4">4×</option>
        </select>
      </label>

      <div class="row2">
        <button id="rerender">Render</button>
        <button id="randomize">Randomize Lines</button>
        <button id="toggleRule">Fill Rule: <span id="ruleTxt">evenodd</span></button>
      </div>

      <p class="small">
        CPU: per‑tile span fills in parallel (workers). WebGPU: per‑pixel compute over per‑tile shape lists, SSAA in shader, then full‑screen blit.
        Strokes: <strong>round/bevel/miter</strong> joins and <strong>round/butt/square</strong> caps.
      </p>

      <div class="row2">
        <div class="stat"><div class="small">Build</div><div class="mono" id="tBuild">–</div></div>
        <div class="stat"><div class="small">Raster</div><div class="mono" id="tRaster">–</div></div>
        <div class="stat"><div class="small">Tiles</div><div class="mono" id="tTiles">–</div></div>
      </div>

      <div style="margin-top:12px">
        <strong>Path Builder Playground</strong>
        <textarea id="code" class="mono" style="width:100%; height:480px; background:#0b0e1d; color:#cfe1ff; border:1px solid #2e3569; border-radius:8px; padding:8px;">
// This code runs inside an async function (you can await).
const W = api.width(), H = api.height();
const yellow = api.color(250,245,140,255);
const sky    = api.color( 88,156,255,220);
const coral  = api.color(255,120, 88,190);
const white  = api.color(235,240,250,255);

// Load a robust CORS-friendly font; fallback stroke font if unavailable.
const FONT_URL = 'https://raw.githubusercontent.com/IBM/plex/master/IBM-Plex-Sans/fonts/complete/ttf/IBM-Plex-Sans-Regular.ttf';
const font = await api.loadFont(FONT_URL);

// 1) Filled star (center)
api.fillPath(
  api.path().poly(api.star(W*0.5, H*0.35, Math.min(W,H)*0.26, Math.min(W,H)*0.11, 7)).closePath(),
  sky, api.rule()
);

// 2) Blobby polygon (bottom-left)
const blob = api.path()
  .ellipse(W*0.26, H*0.68, Math.min(W,H)*0.12, Math.min(W,H)*0.08, 0)
  .transform({scaleX:1.06, scaleY:1.0, rotate:0.08})
  .closePath();
api.fillPath(blob, coral, api.rule());

// 3) Random polyline stroke (UI join/cap/miter)
api.strokePath(
  api.path().poly(api.randomPolyline(220)),
  api.param('strokeWidth'),
  yellow,
  { join: api.param('join'), cap: api.param('cap'), miterLimit: api.param('miterLimit') }
);

// 4) Curves: cubic + quadratic
const p = api.path().moveTo(W*0.12, H*0.15)
  .bezierTo(W*0.28,H*0.06, W*0.42,H*0.28, W*0.52,H*0.15)
  .quadTo  (W*0.64,H*0.03, W*0.78,H*0.16);
api.strokePath(p, 8, api.color(160,220,255,255), { join:'round', cap:'round' });

// 5) Text: outlines → polygons, centered
api.fillText  (font, "Prefix‑Sum + WebGPU", W*0.5, H*0.86, 44, white, { align:'center' });
api.strokeText(font, "Round  •  Bevel  •  Miter", W*0.5, H*0.92, 28, 3, yellow, { align:'center', join:'miter', cap:'butt' });

// 6) SVG arcs (ellipse) scaled to canvas space
const dLens = "M 480 240 m -160 0 a 160 120 0 1 0 320 0 a 160 120 0 1 0 -320 0 z";
const lens = api.svgPath(dLens).transform({ scaleX: W/960, scaleY: H/540 });
api.fillPath(lens, api.color(120, 210, 180, 170), api.rule());

// 7) SVG infinity path
const dInfinity = "M 120 270 C 200 110 360 110 440 270 C 520 430 680 430 760 270";
const inf = api.svgPath(dInfinity).transform({ scaleX: W/880, scaleY: H/540 });
api.strokePath(inf, 16, api.color(240, 220, 120, 255), { join: api.param('join'), cap: api.param('cap'), miterLimit: api.param('miterLimit') });
        </textarea>

        <div style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap;">
          <button id="run">Run Code</button>
          <button id="reset">Reset to Example</button>
          <button id="helpBtn">API Help</button>
        </div>

        <p class="small">
          API: <span class="mono">api.path() → moveTo, lineTo, quadTo, bezierTo, arc, rect, ellipse, transform, poly, closePath</span>.  
          <span class="mono">api.fillPath(path, rgba, rule), api.strokePath(path, width, rgba, { join, cap, miterLimit })</span>.  
          Text: <span class="mono">api.loadFont(), api.fillText(), api.strokeText()</span>.  
          SVG: <span class="mono">api.svgPath(d), api.fillSVG(d,...), api.strokeSVG(d,...)</span>.
        </p>
      </div>
    </div>

    <div class="panel">
      <!-- CPU canvas -->
      <canvas id="cv" width="800" height="600"></canvas>
      <!-- WebGPU canvas (hidden by default; we toggle visibility) -->
      <canvas id="cvgpu" width="800" height="600" style="display:none"></canvas>
    </div>
  </div>

  <dialog id="helpDlg">
    <h3>Path Builder API</h3>
    <pre class="mono" style="white-space:pre-wrap; line-height:1.25">// Paths (multi‑subpath, path‑level transform)
api.path()
  .moveTo(x, y) .lineTo(x, y)
  .quadTo(cpx, cpy, x, y)
  .bezierTo(c1x, c1y, c2x, c2y, x, y)
  .arc(cx, cy, r, a0, a1, ccw?) .rect(x, y, w, h, rx?)
  .ellipse(cx, cy, rx, ry, rot=0)
  .poly([[x,y], ...])
  .transform({translateX,translateY,scaleX,scaleY,rotate})
  .closePath();

// Fill / Stroke
api.fillPath(path, rgba, rule?)
api.strokePath(path, width, rgba, { join:'round|bevel|miter', cap:'round|butt|square', miterLimit:4 })

// Text (opentype.js; fallback stroke font)
const font = await api.loadFont('*.ttf');
api.fillText(font, "Hello", x, y, size, rgba, { align:'left|center|right' });
api.strokeText(font, "World", x, y, size, width, rgba, { join, cap, miterLimit });

// SVG
const p = api.svgPath("M10 10 h 80 v 80 h -80 Z");
api.fillPath(p, rgba, api.rule());
api.strokePath(p, width, rgba, { join, cap, miterLimit });

// Helpers
api.star(cx,cy,rOuter,rInner,n)
api.randomPolyline(n)
api.color(r,g,b,a)
api.rule(), api.width(), api.height(), api.param(...)
    </pre>
    <div style="text-align:right; margin-top:8px;"><button id="helpClose">Close</button></div>
  </dialog>

<script>
(function(){
  // ===============================
  // DOM & controls
  // ===============================
  const cvCPU = document.getElementById('cv');
  const ctx2D = cvCPU.getContext('2d');
  const cvGPU = document.getElementById('cvgpu');
  let gpuCtx = null, gpuDevice = null, gpuAdapter = null, gpuFormat = null;
  let gpuPipelines = null, gpuResources = null;

  const rendererSel = document.getElementById('renderer');
  const sizeSel = document.getElementById('size');
  const tileInp = document.getElementById('tile'); const tileVal = document.getElementById('tileVal');
  const workersInp = document.getElementById('workers'); const workersVal = document.getElementById('workersVal');
  const strokeInp = document.getElementById('stroke'); const strokeVal = document.getElementById('strokeVal');
  const joinSel = document.getElementById('join');
  const capSel = document.getElementById('cap');
  const miterInp = document.getElementById('miter'); const miterVal = document.getElementById('miterVal');
  const aaSel = document.getElementById('aa');
  const btnRender = document.getElementById('rerender');
  const btnRandom = document.getElementById('randomize');
  const btnRule = document.getElementById('toggleRule'); const ruleTxt = document.getElementById('ruleTxt');
  const tBuild = document.getElementById('tBuild'); const tRaster = document.getElementById('tRaster'); const tTiles = document.getElementById('tTiles');
  const codeEl = document.getElementById('code');
  const btnRun = document.getElementById('run');
  const btnReset = document.getElementById('reset');
  const helpBtn = document.getElementById('helpBtn');
  const helpDlg = document.getElementById('helpDlg');
  const helpClose = document.getElementById('helpClose');

  const HW = Math.max(1, Math.min(16, (navigator.hardwareConcurrency||4)));
  workersInp.max = String(HW); workersInp.value = String(Math.min(4, HW));
  workersVal.textContent = workersInp.value;

  tileInp.addEventListener('input', () => tileVal.textContent = tileInp.value);
  workersInp.addEventListener('input', () => workersVal.textContent = workersInp.value);
  strokeInp.addEventListener('input', () => strokeVal.textContent = strokeInp.value);
  miterInp.addEventListener('input', () => miterVal.textContent = miterInp.value);

  let fillRule = 'evenodd';
  btnRule.addEventListener('click', () => { fillRule = (fillRule==='evenodd')?'nonzero':'evenodd'; ruleTxt.textContent = fillRule; });

  sizeSel.addEventListener('change', async () => {
    const [w,h]=sizeSel.value.split('x').map(Number);
    setCanvasSize(w,h);
    await draw();
  });
  rendererSel.addEventListener('change', async () => {
    selectCanvasForRenderer();
    await draw();
  });

  btnRender.addEventListener('click', draw);
  btnRandom.addEventListener('click', () => { randomizeLines(true); draw(); });
  btnRun.addEventListener('click', draw);
  btnReset.addEventListener('click', () => { location.reload(); });
  helpBtn.addEventListener('click', () => { if (typeof helpDlg.showModal==='function') helpDlg.showModal(); else alert('Dialog unsupported. See the API snippet.'); });
  helpClose.addEventListener('click', () => helpDlg.close());

  function setCanvasSize(w,h){
    cvCPU.width=w; cvCPU.height=h;
    cvGPU.width=w; cvGPU.height=h;
    cvCPU.style.width='100%'; cvGPU.style.width='100%';
  }
  function selectCanvasForRenderer(){
    const want = rendererSel.value;
    const hasGPU = !!navigator.gpu;
    const useGPU = (want==='webgpu') || (want==='auto' && hasGPU);
    cvGPU.style.display = useGPU ? '' : 'none';
    cvCPU.style.display = useGPU ? 'none' : '';
  }
  selectCanvasForRenderer();

  // ===============================
  // Math & geometry helpers
  // ===============================
  const TAU = Math.PI*2;
  function angleOf(dx,dy){ return Math.atan2(dy,dx); }
  function norm(dx,dy){ const L=Math.hypot(dx,dy)||1; return [-dy/L, dx/L]; }
  function unit(dx,dy){ const L=Math.hypot(dx,dy)||1; return [dx/L, dy/L]; }
  function arcPoints(cx,cy,r,a0,a1,ccw,segments){
    let sweep = a1 - a0;
    if (ccw && sweep < 0) sweep += TAU; else if (!ccw && sweep > 0) sweep -= TAU;
    const steps = Math.max(1, Math.ceil(Math.abs(sweep) / (Math.PI/10))); // ~18°
    const n = Math.min(segments||steps,64);
    const pts=[]; for (let i=0;i<=n;i++){
      const t=i/Math.max(1,n); const a = a0 + sweep*t;
      pts.push([cx+Math.cos(a)*r, cy+Math.sin(a)*r]);
    }
    return pts;
  }
  function lineIntersect(p0, v0, p1, v1){
    const [x0,y0]=p0,[vx0,vy0]=v0,[x1,y1]=p1,[vx1,vy1]=v1;
    const d = vx0*vy1 - vy0*vx1; if (Math.abs(d) < 1e-6) return null;
    const t = ((x1-x0)*vy1 - (y1-y0)*vx1) / d;
    return [x0 + t*vx0, y0 + t*vy0];
  }

  // ===============================
  // Stroke expansion (round/bevel/miter joins & caps)
  // ===============================
  function strokeToPolys(polyline, width, opts={}){
    const join = opts.join||'round';
    const cap = opts.cap||'round';
    const miterLimit = (opts.miterLimit!=null)? +opts.miterLimit : 4;
    const polys=[]; if (polyline.length<2) return polys; const hw=width*0.5;

    const isClosed = (polyline.length>=3) &&
      (polyline[0][0]===polyline[polyline.length-1][0]) &&
      (polyline[0][1]===polyline[polyline.length-1][1]);
    const N=polyline.length;

    // segment quads
    for (let i=0;i<N-1;i++){
      const [x0,y0]=polyline[i], [x1,y1]=polyline[i+1];
      const dx=x1-x0, dy=y1-y0; const L=Math.hypot(dx,dy); if (L===0) continue;
      const [nx,ny]=norm(dx,dy); const hx=nx*hw, hy=ny*hw;
      polys.push(Float32Array.from([ x0-hx, y0-hy,  x0+hx, y0+hy,  x1+hx, y1+hy,  x1-hx, y1-hy ]));
    }

    // caps if open
    if (!isClosed){
      const [sx0,sy0]=polyline[0], [sx1,sy1]=polyline[1];
      const [exN1,eyN1]=polyline[N-2], [ex,ey]=polyline[N-1];
      const sa=angleOf(sx0-sx1,sy0-sy1), ea=angleOf(ex-exN1,ey-eyN1);
      if (cap==='round'){
        const cap0 = arcPoints(sx0,sy0,hw,sa-Math.PI/2,sa+Math.PI/2,true,Math.ceil(hw/2));
        const fan0=[sx0,sy0]; for (const [x,y] of cap0) fan0.push(x,y); polys.push(Float32Array.from(fan0));
        const cap1 = arcPoints(ex,ey,hw,ea-Math.PI/2,ea+Math.PI/2,true,Math.ceil(hw/2));
        const fan1=[ex,ey]; for (const [x,y] of cap1) fan1.push(x,y); polys.push(Float32Array.from(fan1));
      } else if (cap==='square'){
        const [ux,uy]=unit(sx0-sx1,sy0-sy1); const [nx,ny]=norm(sx0-sx1,sy0-sy1);
        polys.push(Float32Array.from([
          sx0-nx*hw, sy0-ny*hw,
          sx0+nx*hw, sy0+ny*hw,
          sx0+nx*hw+ux*hw, sy0+ny*hw+uy*hw,
          sx0-nx*hw+ux*hw, sy0-ny*hw+uy*hw
        ]));
        const [ux2,uy2]=unit(ex-exN1,ey-eyN1); const [nx2,ny2]=norm(ex-exN1,ey-eyN1);
        polys.push(Float32Array.from([
          ex-nx2*hw, ey-ny2*hw,
          ex+nx2*hw, ey+ny2*hw,
          ex+nx2*hw+ux2*hw, ey+ny2*hw+uy2*hw,
          ex-nx2*hw+ux2*hw, ey-ny2*hw+uy2*hw
        ]));
      }
    }

    // joins
    const first = isClosed ? 0 : 1;
    const last  = isClosed ? N-1 : N-2;
    for (let i=first;i<=last;i++){
      const im1=(i-1+N)%N, ip1=(i+1)%N;
      const [xa,ya]=polyline[im1], [xb,yb]=polyline[i], [xc,yc]=polyline[ip1];
      const v0x=xb-xa, v0y=yb-ya; const v1x=xc-xb, v1y=yc-yb;
      if ((v0x===0 && v0y===0) || (v1x===0 && v1y===0)) continue;

      const a0=angleOf(v0x,v0y), a1=angleOf(v1x,v1y);
      const n0=a0+Math.PI/2, n1=a1+Math.PI/2;
      const cross=(v0x*v1y - v0y*v1x); const ccw=cross>0;

      if (join==='round'){
        const arc=arcPoints(xb,yb,hw,n0,n1,ccw,Math.ceil(width/2));
        const fan=[xb,yb]; for (const [x,y] of arc) fan.push(x,y); polys.push(Float32Array.from(fan));
        continue;
      }

      const s = ccw ? +1 : -1;
      const [n0x,n0y]=[Math.cos(n0)*s, Math.sin(n0)*s];
      const [n1x,n1y]=[Math.cos(n1)*s, Math.sin(n1)*s];
      const p0=[xb + n0x*hw, yb + n0y*hw];
      const p1=[xb + n1x*hw, yb + n1y*hw];

      if (join==='bevel'){
        polys.push(Float32Array.from([xb,yb, p0[0],p0[1], p1[0],p1[1]]));
      } else if (join==='miter'){
        const [t0x,t0y]=unit(v0x,v0y); const [t1x,t1y]=unit(v1x,v1y);
        const m = lineIntersect(p0,[t0x,t0y], p1,[t1x,t1y]);
        if (!m){ polys.push(Float32Array.from([xb,yb, p0[0],p0[1], p1[0],p1[1]])); continue; }
        const ml = Math.hypot(m[0]-xb, m[1]-yb) / hw;
        if (!isFinite(ml) || ml>miterLimit){
          polys.push(Float32Array.from([xb,yb, p0[0],p0[1], p1[0],p1[1]]));
        } else {
          polys.push(Float32Array.from([xb,yb, p0[0],p0[1], m[0],m[1], p1[0],p1[1]]));
        }
      }
    }
    return polys;
  }

  // ===============================
  // SVG path parser (M L H V C S Q T A Z)
  // ===============================
  function parseSVGPathToPath(d){
    const p = new Path();
    const re = /([MmZzLlHhVvCcSsQqTtAa])|([+-]?(?:\d*\.\d+|\d+)(?:[eE][+-]?\d+)?)/g;
    const toks=[]; d.replace(re,(m,cmd,num)=>toks.push(cmd||parseFloat(num)));

    let i=0, cmd=null;
    let cx=0, cy=0, sx=0, sy=0;
    let prevC=null, prevQ=null;

    function read(n){ const out=[]; for(let k=0;k<n;k++){ if (i>=toks.length || typeof toks[i]==='string') throw new Error('Bad SVG path data'); out.push(toks[i++]); } return out; }
    function hasNum(){ return i<toks.length && typeof toks[i] !== 'string'; }
    const DEG = Math.PI/180;

    function arcToPoints(x0,y0, rx,ry, phiDeg, largeArc, sweep, x1,y1){
      const phi = (phiDeg%360)*DEG, cosphi=Math.cos(phi), sinphi=Math.sin(phi);
      if (rx===0 || ry===0) return [[x1,y1]];
      const dx2=(x0-x1)/2, dy2=(y0-y1)/2;
      const x1p= cosphi*dx2 + sinphi*dy2;
      const y1p=-sinphi*dx2 + cosphi*dy2;

      let rx2=rx*rx, ry2=ry*ry;
      const lam=(x1p*x1p)/rx2 + (y1p*y1p)/ry2;
      if (lam>1){ const s=Math.sqrt(lam); rx*=s; ry*=s; rx2=rx*rx; ry2=ry*ry; }

      const sign=(largeArc===sweep)?-1:1;
      const num=rx2*ry2 - rx2*y1p*y1p - ry2*x1p*x1p;
      const den=rx2*y1p*y1p + ry2*x1p*x1p;
      const coef=sign*Math.sqrt(Math.max(0,num/den));
      const cxp=coef*(rx*y1p)/ry;
      const cyp=coef*(-ry*x1p)/rx;

      const cxAbs=cosphi*cxp - sinphi*cyp + (x0+x1)/2;
      const cyAbs=sinphi*cxp + cosphi*cyp + (y0+y1)/2;

      function unit(vx,vy){ const L=Math.hypot(vx,vy)||1; return [vx/L, vy/L]; }
      function ang(u,v){ const a=Math.acos(Math.max(-1,Math.min(1,u[0]*v[0]+u[1]*v[1]))); return (u[0]*v[1]-u[1]*v[0])<0?-a:a; }

      const u=unit((x1p-cxp)/rx, (y1p-cyp)/ry);
      const v=unit((-x1p-cxp)/rx, (-y1p-cyp)/ry);
      let theta=ang([1,0],u), delta=ang(u,v);
      if (!sweep && delta>0) delta-=TAU;
      if ( sweep && delta<0) delta+=TAU;

      const segs=Math.max(1,Math.ceil(Math.abs(delta)/(Math.PI/12))); // ~15°
      const pts=[];
      for(let k=1;k<=segs;k++){
        const t=k/segs, a=theta+delta*t;
        const x=cxAbs + rx*Math.cos(a)*cosphi - ry*Math.sin(a)*sinphi;
        const y=cyAbs + rx*Math.cos(a)*sinphi + ry*Math.sin(a)*cosphi;
        pts.push([x,y]);
      }
      return pts;
    }

    while(i<toks.length){
      if (typeof toks[i]==='string') cmd=toks[i++]; else if (!cmd) throw new Error('SVG path must start with a command');

      switch(cmd){
        case 'M': case 'm': {
          const rel=(cmd==='m');
          const [x,y]=read(2); const nx=rel?cx+x:x, ny=rel?cy+y:y;
          p.moveTo(nx,ny); cx=nx; cy=ny; sx=nx; sy=ny; prevC=prevQ=null;
          while(hasNum()){
            const [x2,y2]=read(2); const nx2=rel?cx+x2:x2, ny2=rel?cy+y2:y2;
            p.lineTo(nx2,ny2); cx=nx2; cy=ny2; prevC=prevQ=null;
          }
          break;
        }
        case 'L': case 'l': {
          const rel=(cmd==='l');
          while(hasNum()){
            const [x,y]=read(2); const nx=rel?cx+x:x, ny=rel?cy+y:y;
            p.lineTo(nx,ny); cx=nx; cy=ny; prevC=prevQ=null;
          } break;
        }
        case 'H': case 'h': {
          const rel=(cmd==='h');
          while(hasNum()){
            const [x]=read(1); const nx=rel?cx+x:x;
            p.lineTo(nx,cy); cx=nx; prevC=prevQ=null;
          } break;
        }
        case 'V': case 'v': {
          const rel=(cmd==='v');
          while(hasNum()){
            const [y]=read(1); const ny=rel?cy+y:y;
            p.lineTo(cx,ny); cy=ny; prevC=prevQ=null;
          } break;
        }
        case 'C': case 'c': {
          const rel=(cmd==='c');
          while(hasNum()){
            const [x1,y1,x2,y2,x,y]=read(6);
            const c1x=rel?cx+x1:x1, c1y=rel?cy+y1:y1;
            const c2x=rel?cx+x2:x2, c2y=rel?cy+y2:y2;
            const nx =rel?cx+x :x , ny =rel?cy+y :y ;
            p.bezierTo(c1x,c1y,c2x,c2y,nx,ny);
            prevC=[c2x,c2y]; prevQ=null; cx=nx; cy=ny;
          } break;
        }
        case 'S': case 's': {
          const rel=(cmd==='s');
          while(hasNum()){
            const [x2,y2,x,y]=read(4);
            let c1x=cx, c1y=cy;
            if (prevC){ c1x=2*cx-prevC[0]; c1y=2*cy-prevC[1]; }
            const c2x=rel?cx+x2:x2, c2y=rel?cy+y2:y2;
            const nx =rel?cx+x :x , ny =rel?cy+y :y ;
            p.bezierTo(c1x,c1y,c2x,c2y,nx,ny);
            prevC=[c2x,c2y]; prevQ=null; cx=nx; cy=ny;
          } break;
        }
        case 'Q': case 'q': {
          const rel=(cmd==='q');
          while(hasNum()){
            const [x1,y1,x,y]=read(4);
            const cpx=rel?cx+x1:x1, cpy=rel?cy+y1:y1;
            const nx =rel?cx+x :x , ny =rel?cy+y :y ;
            p.quadTo(cpx,cpy,nx,ny);
            prevQ=[cpx,cpy]; prevC=null; cx=nx; cy=ny;
          } break;
        }
        case 'T': case 't': {
          const rel=(cmd==='t');
          while(hasNum()){
            const [x,y]=read(2);
            let cpx=cx, cpy=cy;
            if (prevQ){ cpx=2*cx-prevQ[0]; cpy=2*cy-prevQ[1]; }
            const nx=rel?cx+x:x, ny=rel?cy+y:y;
            p.quadTo(cpx,cpy,nx,ny);
            prevQ=[cpx,cpy]; prevC=null; cx=nx; cy=ny;
          } break;
        }
        case 'A': case 'a': {
          const rel=(cmd==='a');
          while(hasNum()){
            const [rx,ry,phi,laf,sf,x,y]=read(7);
            const nx=rel?cx+x:x, ny=rel?cy+y:y;
            const pts=arcToPoints(cx,cy, Math.abs(rx),Math.abs(ry), phi, laf?1:0, sf?1:0, nx,ny);
            for (const [px,py] of pts) p.lineTo(px,py);
            cx=nx; cy=ny; prevC=prevQ=null;
          } break;
        }
        case 'Z': case 'z': { p.closePath(); cx=sx; cy=sy; prevC=prevQ=null; break; }
        default: throw new Error('Unknown SVG path command: '+cmd);
      }
    }
    return p;
  }

  // ===============================
  // Prefix scan helper (binning)
  // ===============================
  function exclusiveScan(u32){
    const out=new Uint32Array(u32.length); let acc=0>>>0;
    for(let i=0;i<u32.length;i++){ out[i]=acc; acc=(acc+u32[i])>>>0; }
    return {offsets:out,total:acc>>>0};
  }

  // ===============================
  // Path class (path‑level transform, safe flatten)
  // ===============================
  class Path {
    constructor(){
      this._subs=[[]];
      this._curr=[0,0]; this._hasCurr=false;
      this._tf = { tx:0, ty:0, sx:1, sy:1, rot:0 };
    }
    _sub(){ return this._subs[this._subs.length-1]; }
    moveTo(x,y){ this._curr=[x,y]; this._sub().push({t:'M',x,y}); this._hasCurr=true; return this; }
    lineTo(x,y){ if(!this._hasCurr) this.moveTo(x,y); else this._sub().push({t:'L',x,y}); this._curr=[x,y]; return this; }
    quadTo(cpx,cpy,x,y){ this._sub().push({t:'Q',cpx,cpy,x,y}); this._curr=[x,y]; return this; }
    bezierTo(c1x,c1y,c2x,c2y,x,y){ this._sub().push({t:'C',c1x,c1y,c2x,c2y,x,y}); this._curr=[x,y]; return this; }
    arc(cx,cy,r,a0,a1,ccw=false,segments){ this._sub().push({t:'A',cx,cy,r,a0,a1,ccw,segments}); const a=ccw?a0:a1; this._curr=[cx+Math.cos(a)*r, cy+Math.sin(a)*r]; return this; }
    rect(x,y,w,h,rx=0){
      if(rx<=0){ this.moveTo(x,y).lineTo(x+w,y).lineTo(x+w,y+h).lineTo(x,y+h).closePath(); }
      else { const r=Math.min(rx,Math.min(w,h)/2); const k=0.552284749831; const c=r*k;
        this.moveTo(x+r,y).lineTo(x+w-r,y)
          .bezierTo(x+w-r+c,y, x+w,y+r-c, x+w,y+r)
          .lineTo(x+w,y+h-r)
          .bezierTo(x+w,y+h-r+c, x+w-r+c,y+h, x+w-r,y+h)
          .lineTo(x+r,y+h)
          .bezierTo(x+r-c,y+h, x,y+h-r+c, x,y+h-r)
          .lineTo(x,y+r)
          .bezierTo(x,y+r-c, x+r-c,y, x+r,y)
          .closePath(); }
      return this;
    }
    ellipse(cx,cy,rx,ry,rot=0,segments=64){ this._sub().push({t:'E',cx,cy,rx,ry,rot,segments}); this._curr=[cx+rx*Math.cos(rot), cy+rx*Math.sin(rot)]; return this; }
    poly(pts){ if(pts.length){ const [x0,y0]=pts[0]; this.moveTo(x0,y0); for(let i=1;i<pts.length;i++) this.lineTo(pts[i][0],pts[i][1]); } return this; }
    transform({translateX=0,translateY=0,scaleX=1,scaleY=1,rotate=0}={}){
      this._tf.tx += translateX; this._tf.ty += translateY;
      this._tf.sx *= scaleX; this._tf.sy *= scaleY;
      this._tf.rot += rotate; return this;
    }
    closePath(){ this._sub().push({t:'Z'}); this._subs.push([]); this._hasCurr=false; return this; }

    flatten(tol=0.25){
      const out=[];
      let curr=[0,0], start=[0,0];
      let tx=this._tf.tx, ty=this._tf.ty, sx=this._tf.sx, sy=this._tf.sy, rot=this._tf.rot;

      function apply(x,y){
        const xr=(x*sx), yr=(y*sy);
        const X = xr*Math.cos(rot) - yr*Math.sin(rot) + tx;
        const Y = xr*Math.sin(rot) + yr*Math.cos(rot) + ty;
        return [X,Y];
      }

      let pts=[]; let closed=false;
      function flush(forceClose=false){
        if (pts.length<2){ pts=[]; closed=false; return; }
        const isClosed = forceClose || closed;
        const n = pts.length*2 + (isClosed?2:0);
        const flat = new Float32Array(n);
        for (let i=0;i<pts.length;i++){ flat[i*2]=pts[i][0]; flat[i*2+1]=pts[i][1]; }
        if (isClosed){ flat[n-2]=pts[0][0]; flat[n-1]=pts[0][1]; }
        out.push(flat);
        pts=[]; closed=false;
      }

      for (const sub of this._subs){
        if (!sub.length) continue;
        for (const cmd of sub){
          if (cmd.t==='M'){ flush(false); start=apply(cmd.x,cmd.y); curr=start; pts.push(start); continue; }
          if (cmd.t==='L'){ const p=apply(cmd.x,cmd.y); pts.push(p); curr=p; continue; }

          if (cmd.t==='Q'){
            const [x0,y0]=curr; const p1=apply(cmd.cpx,cmd.cpy); const p2=apply(cmd.x,cmd.y);
            const stack=[[x0,y0,p1[0],p1[1],p2[0],p2[1],0]];
            while(stack.length){
              const [x0,y0,cx,cy,x1,y1,depth]=stack.pop();
              const mx=(x0+2*cx+x1)/4, my=(y0+2*cy+y1)/4;
              const lx=(x0+x1)/2, ly=(y0+y1)/2;
              const err=Math.hypot(mx-lx,my-ly);
              if (err<=tol || depth>10){ pts.push([x1,y1]); }
              else {
                const q0x=(x0+cx)/2, q0y=(y0+cy)/2;
                const q1x=(cx+x1)/2, q1y=(cy+y1)/2;
                const hx=(q0x+q1x)/2, hy=(q0y+q1y)/2;
                stack.push([hx,hy,q1x,q1y,x1,y1,depth+1]);
                stack.push([x0,y0,q0x,q0y,hx,hy,depth+1]);
              }
            }
            curr=p2; continue;
          }

          if (cmd.t==='C'){
            const [x0,y0]=curr;
            const p1=apply(cmd.c1x,cmd.c1y), p2=apply(cmd.c2x,cmd.c2y), p3=apply(cmd.x,cmd.y);
            const stack=[[x0,y0,p1[0],p1[1],p2[0],p2[1],p3[0],p3[1],0]];
            while(stack.length){
              const [x0,y0,c1x,c1y,c2x,c2y,x1,y1,depth]=stack.pop();
              const dx = x1 - x0, dy = y1 - y0;
              const d1 = Math.abs((c1x - x1)*dy - (c1y - y1)*dx);
              const d2 = Math.abs((c2x - x1)*dy - (c2y - y1)*dx);
              if ((d1 + d2) <= tol*6 || depth>10){ pts.push([x1,y1]); }
              else {
                const x01=(x0+c1x)/2, y01=(y0+c1y)/2;
                const x12=(c1x+c2x)/2, y12=(c1y+c2y)/2;
                const x23=(c2x+x1)/2, y23=(c2y+y1)/2;
                const xa=(x01+x12)/2, ya=(y01+y12)/2;
                const xb=(x12+x23)/2, yb=(y12+y23)/2;
                const xm=(xa+xb)/2, ym=(ya+yb)/2;
                stack.push([xm,ym,xb,yb,x23,y23,x1,y1,depth+1]);
                stack.push([x0,y0,x01,y01,xa,ya,xm,ym,depth+1]);
              }
            }
            curr=p3; continue;
          }

          if (cmd.t==='A'){
            const ptsArc=arcPoints(cmd.cx,cmd.cy,cmd.r,cmd.a0,cmd.a1,cmd.ccw,cmd.segments||Math.ceil(cmd.r/2));
            for (let i=1;i<ptsArc.length;i++) pts.push(ptsArc[i]);
            curr=ptsArc[ptsArc.length-1]; continue;
          }

          if (cmd.t==='E'){
            const {cx,cy,rx,ry,rot,segments}=cmd;
            const steps=Math.max(8,Math.min(segments||64,256));
            for(let i=1;i<=steps;i++){
              const t=i/steps*TAU;
              const x=cx+rx*Math.cos(t), y=cy+ry*Math.sin(t);
              const xr=(x-cx), yr=(y-cy);
              const X = xr*Math.cos(rot)-yr*Math.sin(rot)+cx;
              const Y = xr*Math.sin(rot)+yr*Math.cos(rot)+cy;
              pts.push([X,Y]);
            }
            curr=pts[pts.length-1]; continue;
          }

          if (cmd.t==='Z'){ closed=true; flush(true); continue; }
        }
        flush(false);
      }
      return out;
    }
  }

  // ===============================
  // Fallback "stroke" font (with punctuation) & opentype loader
  // ===============================
  const SIMPLE_FONT = {
    h:10, a:6, map: {
      ' ':[], '.':[[3,10],[3,10]], ',':[[3,10],[2,12]], '-':[[1,5],[5,5]], ':':[[3,3],[3,3],[3,8],[3,8]],
      'A':[[0,10],[3,0],[6,10]], 'B':[[0,0],[0,10],[4,10],[5,9],[5,6],[4,5],[0,5],[4,5],[5,4],[5,1],[4,0],[0,0]],
      'C':[[6,1],[5,0],[1,0],[0,1],[0,9],[1,10],[5,10],[6,9]],
      'D':[[0,0],[0,10],[3,10],[6,7],[6,3],[3,0],[0,0]],
      'E':[[6,0],[0,0],[0,10],[6,10],[0,10],[0,5],[5,5],[0,5],[0,0],[6,0]],
      'F':[[0,0],[0,10],[6,10],[0,10],[0,5],[5,5]],
      'G':[[6,1],[5,0],[1,0],[0,1],[0,9],[1,10],[5,10],[6,9],[6,6],[3,6]],
      'H':[[0,0],[0,10],[0,5],[6,5],[6,10],[6,0]],
      'I':[[0,0],[6,0],[3,0],[3,10],[0,10],[6,10]],
      'J':[[6,10],[6,2],[5,0],[3,0],[1,1],[0,3]],
      'K':[[0,0],[0,10],[0,5],[6,10],[0,5],[6,0]],
      'L':[[0,10],[0,0],[6,0]],
      'M':[[0,0],[0,10],[3,6],[6,10],[6,0]],
      'N':[[0,0],[0,10],[6,0],[6,10]],
      'O':[[1,0],[5,0],[6,1],[6,9],[5,10],[1,10],[0,9],[0,1],[1,0]],
      'P':[[0,0],[0,10],[4,10],[5,9],[5,7],[4,6],[0,6]],
      'Q':[[1,0],[5,0],[6,1],[6,9],[5,10],[1,10],[0,9],[0,1],[1,0],[4,3],[6,0]],
      'R':[[0,0],[0,10],[4,10],[5,9],[5,7],[4,6],[0,6],[4,6],[6,0]],
      'S':[[6,1],[5,0],[1,0],[0,1],[0,4],[1,5],[5,5],[6,6],[6,9],[5,10],[1,10],[0,9]],
      'T':[[0,10],[6,10],[3,10],[3,0]],
      'U':[[0,10],[0,2],[1,0],[5,0],[6,2],[6,10]],
      'V':[[0,10],[3,0],[6,10]],
      'W':[[0,10],[2,0],[3,5],[4,0],[6,10]],
      'X':[[0,10],[6,0],[3,5],[0,0],[6,10]],
      'Y':[[0,10],[3,6],[3,0],[3,6],[6,10]],
      'Z':[[0,10],[6,10],[0,0],[6,0]],
      '0':[[1,0],[5,0],[6,1],[6,9],[5,10],[1,10],[0,9],[0,1],[1,0],[5,10]],
      '1':[[1,8],[3,10],[3,0],[0,0],[6,0]],
      '2':[[0,9],[1,10],[5,10],[6,9],[6,7],[0,0],[6,0]],
      '3':[[0,10],[6,10],[3,6],[5,6],[6,5],[6,1],[5,0],[1,0],[0,1]],
      '4':[[6,6],[0,6],[4,10],[4,0]],
      '5':[[6,10],[0,10],[0,6],[5,6],[6,5],[6,1],[5,0],[1,0],[0,1]],
      '6':[[6,9],[5,10],[1,10],[0,9],[0,1],[1,0],[5,0],[6,1],[6,5],[5,6],[0,6]],
      '7':[[0,10],[6,10],[1,0]],
      '8':[[1,5],[0,6],[0,9],[1,10],[5,10],[6,9],[6,6],[5,5],[1,5],[0,4],[0,1],[1,0],[5,0],[6,1],[6,4],[5,5]],
      '9':[[6,5],[5,6],[1,6],[0,5],[0,1],[1,0],[5,0],[6,1],[6,9],[5,10],[1,10],[0,9]]
    }
  };

  async function loadOpentype(){
    if (window.opentype) return window.opentype;
    try{
      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/opentype.js@latest/dist/opentype.min.js';
        s.onload = resolve; s.onerror = reject;
        document.head.appendChild(s);
      });
      return window.opentype || null;
    } catch (e) {
      console.warn('opentype.js failed to load; using SIMPLE_FONT fallback.', e);
      return null;
    }
  }
  async function loadFont(urlOrBuffer){
    const ot = await loadOpentype();
    if (!ot) return { __simple: true };
    try {
      if (typeof urlOrBuffer === 'string') {
        return await new Promise((res, rej) =>
          ot.load(urlOrBuffer, (err, font) => err ? rej(err) : res(font))
        );
      } else {
        return ot.parse(urlOrBuffer);
      }
    } catch (e) {
      console.warn('Font load failed, using SIMPLE_FONT fallback:', e);
      return { __simple: true };
    }
  }

  function textToPath(font, text, x, y, size, opts={}){
    const align = opts.align||'left';
    const letterSpacing = +opts.letterSpacing||0;

    if (font && !font.__simple && font.getPath){
      const options = { kerning: true, features: { liga: true } };
      let adv = font.getAdvanceWidth(text, size, options) + letterSpacing * Math.max(0, text.length-1);
      let penX = x, penY = y;
      if (align==='center') penX -= adv*0.5;
      else if (align==='right') penX -= adv;

      const gp = font.getPath(text, penX, penY, size, options);
      const path = new Path();
      let open=false;
      for (const c of gp.commands){
        if (c.type==='M'){ path.moveTo(c.x, c.y); open=true; }
        else if (c.type==='L'){ path.lineTo(c.x, c.y); }
        else if (c.type==='Q'){ path.quadTo(c.x1,c.y1, c.x,c.y); }
        else if (c.type==='C'){ path.bezierTo(c.x1,c.y1, c.x2,c.y2, c.x,c.y); }
        else if (c.type==='Z'){ path.closePath(); open=false; }
      }
      if (open) path.closePath();
      return path;
    }

    // fallback stroke font
    const path = new Path();
    const adv = SIMPLE_FONT.a * (size/SIMPLE_FONT.h);
    let penX = x, penY=y; const s = size/SIMPLE_FONT.h;

    if (align!=='left'){
      let count=0; for (const _ of text){ count++; }
      const width = count*adv + Math.max(0,count-1)*letterSpacing;
      if (align==='center') penX -= width/2; else if (align==='right') penX -= width;
    }

    for (const raw of text){
      const ch = (SIMPLE_FONT.map[raw] ? raw : raw.toUpperCase());
      const poly = SIMPLE_FONT.map[ch];
      if (poly && poly.length){
        const [x0,y0] = [penX + poly[0][0]*s, penY + (SIMPLE_FONT.h-poly[0][1])*s];
        path.moveTo(x0,y0);
        for (let i=1;i<poly.length;i++){
          const px = penX + poly[i][0]*s;
          const py = penY + (SIMPLE_FONT.h-poly[i][1])*s;
          path.lineTo(px,py);
        }
      }
      penX += (raw===' ' ? adv*0.6 : adv) + letterSpacing;
    }
    return path;
  }

  // ===============================
  // Path Builder API
  // ===============================
  let randomLines=[];
  function randomizeLines(forceNew=false){
    const [W,H]=[cvCPU.width,cvCPU.height]; const pts=[]; const N=220; let x=W*0.15,y=H*0.25; const step=Math.min(W,H)*0.03;
    for(let i=0;i<N;i++){ x=Math.max(20,Math.min(W-20,x+(Math.random()-0.5)*step*2)); y=Math.max(20,Math.min(H-20,y+(Math.random()-0.5)*step*2)); pts.push([x,y]); }
    if (forceNew || randomLines.length===0) randomLines=pts; return randomLines;
  }
  function star(cx,cy,rOuter,rInner,n=5){ const pts=[]; const step=Math.PI/n; for(let i=0;i<2*n;i++){ const r=(i%2===0)?rOuter:rInner; const a=i*step-Math.PI/2; pts.push([cx+Math.cos(a)*r, cy+Math.sin(a)*r]); } return pts; }

  function createAPI(shapeSink){
    const fillPathImpl = (path, rgba, rule) => {
      const polys = path.flatten(0.35);
      for (const verts of polys){
        if (verts.length<6) continue;
        const n = verts.length;
        const closed = (verts[0]===verts[n-2] && verts[1]===verts[n-1]);
        if (closed) shapeSink.push({ verts, color: rgba, rule: rule||fillRule });
      }
    };
    const strokePathImpl = (path, width, rgba, opts={}) => {
      const flats = path.flatten(0.35);
      for (const flat of flats){
        const pts=[]; for (let i=0;i<flat.length;i+=2) pts.push([flat[i],flat[i+1]]);
        const pieces = strokeToPolys(pts, width, opts);
        for (const poly of pieces) shapeSink.push({ verts: poly, color: rgba, rule: 'evenodd' });
      }
    };

    return {
      width: () => cvCPU.width,
      height: () => cvCPU.height,
      rule: () => fillRule,
      param: (name) => {
        if (name==='strokeWidth') return Number(strokeInp.value);
        if (name==='join') return String(joinSel.value);
        if (name==='cap') return String(capSel.value);
        if (name==='miterLimit') return Number(miterInp.value);
        return undefined;
      },
      color: (r,g,b,a) => Uint8ClampedArray.from([r|0,g|0,b|0,(a|0)]),
      path: () => new Path(),
      star: (cx,cy,ro,ri,n)=>star(cx,cy,ro,ri,n),
      randomPolyline: (N)=> randomizeLines().slice(0,N|0),

      // fonts & text
      loadFont: (src) => loadFont(src),
      textPath: (font, text, x, y, size, opts) => textToPath(font, text, x, y, size, opts),
      fillText: (font, text, x, y, size, rgba, opts={}) => {
        const p = textToPath(font, text, x, y, size, opts);
        const flats = p.flatten(0.35);
        if (font && font.__simple){
          const width = Math.max(1, size*0.12);
          for (const flat of flats){
            const pts=[]; for (let i=0;i<flat.length;i+=2) pts.push([flat[i],flat[i+1]]);
            for (const poly of strokeToPolys(pts, width, { join:'round', cap:'round' }))
              shapeSink.push({ verts: poly, color: rgba, rule: 'evenodd' });
          }
        } else {
          for (const verts of flats){
            if (verts.length >= 6){
              const n = verts.length;
              const closed = (verts[0]===verts[n-2] && verts[1]===verts[n-1]);
              if (closed) shapeSink.push({ verts, color: rgba, rule: fillRule });
            }
          }
        }
      },
      strokeText: (font, text, x, y, size, width, rgba, opts={}) => {
        const p = textToPath(font, text, x, y, size, opts);
        const flats = p.flatten(0.35);
        for (const flat of flats) {
          const pts = []; for (let i=0;i<flat.length;i+=2) pts.push([flat[i], flat[i+1]]);
          for (const poly of strokeToPolys(pts, width, opts))
            shapeSink.push({ verts: poly, color: rgba, rule: 'evenodd' });
        }
      },

      // SVG helpers
      svgPath: (d) => parseSVGPathToPath(d),
      fillSVG: (d, rgba, rule) => fillPathImpl(parseSVGPathToPath(d), rgba, rule),
      strokeSVG: (d, width, rgba, opts={}) => {
        const p = parseSVGPathToPath(d);
        const flats = p.flatten(0.35);
        for (const flat of flats){
          const pts=[]; for (let i=0;i<flat.length;i+=2) pts.push([flat[i],flat[i+1]]);
          for (const poly of strokeToPolys(pts, width, opts))
            shapeSink.push({ verts: poly, color: rgba, rule: 'evenodd' });
        }
      },

      // Core fill/stroke
      fillPath: fillPathImpl,
      strokePath: strokePathImpl,
    };
  }

  async function buildShapesFromCode(code){
    const shapes=[]; const api=createAPI(shapes);
    try {
      const run = new Function('api', `return (async () => { ${code}\n })()`);
      await run(api);
    } catch(e){
      console.error('User code error:', e);
      alert('Error in your code: '+ e.message);
      return null;
    }
    return shapes;
  }

  // ===============================
  // Tiling (count → scan → scatter)
  // ===============================
  function binShapesIntoTiles(shapes,tileSize, W, H){
    const tilesX=Math.ceil(W/tileSize), tilesY=Math.ceil(H/tileSize);
    const tileCount=tilesX*tilesY; const counts=new Uint32Array(tileCount); const ranges=new Array(shapes.length);
    for(let sIdx=0;sIdx<shapes.length;sIdx++){
      const v=shapes[sIdx].verts; let minX=+Infinity,minY=+Infinity,maxX=-Infinity,maxY=-Infinity;
      for(let i=0;i<v.length;i+=2){ const x=v[i],y=v[i+1]; if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; }
      const minTx=Math.max(0,Math.floor(minX/tileSize));
      const maxTx=Math.min(tilesX-1,Math.floor(maxX/tileSize));
      const minTy=Math.max(0,Math.floor(minY/tileSize));
      const maxTy=Math.min(tilesY-1,Math.floor(maxY/tileSize));
      ranges[sIdx]={minTx,maxTx,minTy,maxTy};
      for(let ty=minTy;ty<=maxTy;ty++) for(let tx=minTx;tx<=maxTx;tx++) counts[ty*tilesX+tx]++;
    }
    const {offsets,total}=exclusiveScan(counts); const tileShapeIndex=new Uint32Array(total); const cursors=offsets.slice();
    for (let sIdx=0;sIdx<shapes.length;sIdx++){
      const r=ranges[sIdx];
      for(let ty=r.minTy;ty<=r.maxTy;ty++)
        for(let tx=r.minTx;tx<=r.maxTx;tx++){
          const t=ty*tilesX+tx; tileShapeIndex[cursors[t]++]=sIdx;
        }
    }
    return {tilesX,tilesY,tileCount,counts,offsets,tileShapeIndex};
  }

  // ===============================
  // CPU worker raster (span fills)
  // ===============================
  function makeWorkerURL(){
    const workerFn=()=>{
      function toPremul(rgba){ const a=rgba[3]/255; return [rgba[0]/255*a, rgba[1]/255*a, rgba[2]/255*a, a]; }
      function over(dst,i,sr,sg,sb,sa){ const ida=1-sa; dst[i]=sr+dst[i]*ida; dst[i+1]=sg+dst[i+1]*ida; dst[i+2]=sb+dst[i+2]*ida; dst[i+3]=sa+dst[i+3]*ida; }

      function fillRowEvenOdd(xs, sTileX, sW, base, outF32, sr,sg,sb,sa){
        if (xs.length<2) return;
        xs.sort((a,b)=>a-b);
        for (let k=0; k+1<xs.length; k+=2){
          let x0 = Math.floor(xs[k]   - sTileX);
          let x1 = Math.floor(xs[k+1] - sTileX);
          if (x1<=0 || x0>=sW) continue;
          if (x0<0) x0=0; if (x1>sW) x1=sW;
          let i = base + (x0<<2), end = base + (x1<<2);
          for (; i+16<=end; i+=16){ over(outF32,i,sr,sg,sb,sa); over(outF32,i+4,sr,sg,sb,sa); over(outF32,i+8,sr,sg,sb,sa); over(outF32,i+12,sr,sg,sb,sa); }
          for (; i<end; i+=4){ over(outF32,i,sr,sg,sb,sa); }
        }
      }
      function fillRowNonZero(events, sTileX, sW, base, outF32, sr,sg,sb,sa){
        if (events.length===0) return;
        events.sort((a,b)=>a.x-b.x);
        let w=0, spanStart=null;
        let j=0;
        while (j<events.length){
          const x = events[j].x;
          let sum=0; do { sum += events[j].w; j++; } while(j<events.length && events[j].x===x);
          const prevW = w; w += sum;
          if (prevW===0 && w!==0){
            spanStart = x;
          } else if (prevW!==0 && w===0){
            let x0=Math.floor(spanStart - sTileX);
            let x1=Math.floor(x - sTileX);
            if (x1<=0 || x0>=sW) continue;
            if (x0<0) x0=0; if (x1>sW) x1=sW;
            let i = base + (x0<<2), end = base + (x1<<2);
            for (; i+16<=end; i+=16){ over(outF32,i,sr,sg,sb,sa); over(outF32,i+4,sr,sg,sb,sa); over(outF32,i+8,sr,sg,sb,sa); over(outF32,i+12,sr,sg,sb,sa); }
            for (; i<end; i+=4){ over(outF32,i,sr,sg,sb,sa); }
            spanStart=null;
          }
        }
      }

      function fillPolygonTile(tileX,tileY,tileW,tileH,verts,rgba,rule,outF32,SS){
        const n=verts.length>>>1; if(n<3) return;
        const vx=new Float32Array(n), vy=new Float32Array(n);
        for(let i=0,j=0;i<n;i++,j+=2){ vx[i]=verts[j]*SS; vy[i]=verts[j+1]*SS; }
        const sTileX=tileX*SS, sTileY=tileY*SS, sW=tileW*SS, sH=tileH*SS;
        const pitch=sW*4; const [sr,sg,sb,sa]=toPremul(rgba);

        for(let ry=0; ry<sH; ry++){
          const gy=sTileY+ry+0.5;
          const base=ry*pitch;

          if(rule==='evenodd'){
            const xs=[];
            for(let i=0,j=n-1;i<n;j=i++){
              const x0=vx[j],y0=vy[j],x1=vx[i],y1=vy[i];
              const yMin=(y0<y1)?y0:y1, yMax=(y0>y1)?y0:y1;
              if(gy<=yMin || gy>yMax) continue;
              const t=(gy-y0)/(y1-y0); xs.push(x0+t*(x1-x0));
            }
            fillRowEvenOdd(xs, sTileX, sW, base, outF32, sr,sg,sb,sa);
          } else {
            const ev=[];
            for(let i=0,j=n-1;i<n;j=i++){
              const x0=vx[j],y0=vy[j],x1=vx[i],y1=vy[i];
              const yMin=(y0<y1)?y0:y1, yMax=(y0>y1)?y0:y1;
              if(gy<=yMin || gy>yMax) continue;
              const t=(gy-y0)/(y1-y0); const x=x0+t*(x1-x0);
              ev.push({x, w:(y1>y0)?+1:-1});
            }
            fillRowNonZero(ev, sTileX, sW, base, outF32, sr,sg,sb,sa);
          }
        }
      }

      function downsampleSSAA(srcF32,tileW,tileH,SS){
        if(SS===1){
          const out=new Uint8ClampedArray(tileW*tileH*4);
          for(let p=0;p<tileW*tileH;p++){
            const i=p*4; const a=Math.min(1,Math.max(0,srcF32[i+3]));
            const r=a>1e-6? Math.round((srcF32[i]/a)*255):0;
            const g=a>1e-6? Math.round((srcF32[i+1]/a)*255):0;
            const b=a>1e-6? Math.round((srcF32[i+2]/a)*255):0;
            const A=Math.round(a*255);
            out[i]=r; out[i+1]=g; out[i+2]=b; out[i+3]=A;
          }
          return out;
        }
        const sW=tileW*SS, sH=tileH*SS; const out=new Uint8ClampedArray(tileW*tileH*4);
        const area=SS*SS;
        for(let y=0;y<tileH;y++){
          for(let x=0;x<tileW;x++){
            let r=0,g=0,b=0,a=0;
            const base = (y*sW*SS + x*SS)*4;
            for(let j=0;j<SS;j++){
              let idx=base + j*sW*4;
              for(let i=0;i<SS;i++,idx+=4){
                r+=srcF32[idx]; g+=srcF32[idx+1]; b+=srcF32[idx+2]; a+=srcF32[idx+3];
              }
            }
            r/=area; g/=area; b/=area; a/=area; const o=(y*tileW+x)*4;
            const A=Math.min(1,a);
            out[o  ]=A>1e-6? Math.round((r/A)*255):0;
            out[o+1]=A>1e-6? Math.round((g/A)*255):0;
            out[o+2]=A>1e-6? Math.round((b/A)*255):0;
            out[o+3]=Math.round(A*255);
          }
        }
        return out;
      }

      self.onmessage=(e)=>{
        const msg=e.data; if(msg.cmd!=='renderTiles') return;
        const { tileSize, canvasW, canvasH, tilesX, tileIndices, offsets, counts, tileShapeIndex, shapes, SS } = msg;
        const results=[];
        for(const t of tileIndices){
          const tx=t%tilesX, ty=(t/tilesX)|0;
          const tileX=tx*tileSize, tileY=ty*tileSize;
          const tileW=Math.min(tileSize, canvasW-tileX), tileH=Math.min(tileSize, canvasH-tileY);
          const fbuf=new Float32Array((tileW*SS)*(tileH*SS)*4);
          const start=offsets[t]>>>0, cnt=counts[t]>>>0;
          for(let i=0;i<cnt;i++){
            const sIdx=tileShapeIndex[start+i]>>>0; const sh=shapes[sIdx];
            fillPolygonTile(tileX,tileY,tileW,tileH, sh.verts, sh.color, sh.rule, fbuf, SS);
          }
          const pixels=downsampleSSAA(fbuf,tileW,tileH,SS);
          results.push({ t, tx, ty, tileX, tileY, tileW, tileH, pixels });
        }
        self.postMessage({ kind:'tilesDone', results }, results.map(r=>r.pixels.buffer));
      };
    };
    const src=`(${workerFn.toString()})()`;
    const blob=new Blob([src],{type:'text/javascript'});
    return URL.createObjectURL(blob);
  }

  // ===============================
  // WebGPU setup & pipelines
  // ===============================
  const WGSL_COMPUTE = /* wgsl */`
struct Uniforms {
  canvasW : u32,
  canvasH : u32,
  tileSize: u32,
  tilesX  : u32,
  SS      : u32,
  _padA   : u32,
  _padB   : u32,
  _padC   : u32,
};

struct Shape {
  vStart : u32,
  vCount : u32,
  rule   : u32,   // 0=evenodd, 1=nonzero
  _pad0  : u32,
  color  : vec4f, // premultiplied RGBA in 0..1
};

@group(0) @binding(0) var<uniform> uni : Uniforms;
@group(0) @binding(1) var<storage, read> shapes : array<Shape>;
@group(0) @binding(2) var<storage, read> vertices : array<vec2f>;
@group(0) @binding(3) var<storage, read> tileOffsets : array<u32>;
@group(0) @binding(4) var<storage, read> tileCounts  : array<u32>;
@group(0) @binding(5) var<storage, read> tileShapeIx : array<u32>;
@group(0) @binding(6) var outputTex : texture_storage_2d<rgba8unorm, write>;

fn point_in_evenodd(vStart:u32, vCount:u32, x:f32, y:f32) -> bool {
  var inside = false;
  var i = 0u;
  var j = vCount - 1u;
  loop {
    if (i >= vCount) { break; }
    let pi = vertices[vStart + i];
    let pj = vertices[vStart + j];
    // half-open: (yi>y) != (yj>y) toggle rule
    let cond = ( (pi.y > y) != (pj.y > y) );
    if (cond) {
      let xin = ( (pj.x - pi.x) * (y - pi.y) / (pj.y - pi.y) + pi.x );
      if (x < xin) { inside = !inside; }
    }
    j = i;
    i = i + 1u;
  }
  return inside;
}

fn point_in_nonzero(vStart:u32, vCount:u32, x:f32, y:f32) -> bool {
  var winding : i32 = 0;
  var i = 0u;
  var j = vCount - 1u;
  loop {
    if (i >= vCount) { break; }
    let pi = vertices[vStart + i];
    let pj = vertices[vStart + j];

    if (pi.y <= y) {
      if (pj.y > y) {
        // isLeft
        let l = (pj.x - pi.x) * (y - pi.y) - (x - pi.x) * (pj.y - pi.y);
        if (l > 0.0) { winding = winding + 1; }
      }
    } else {
      if (pj.y <= y) {
        let l = (pj.x - pi.x) * (y - pi.y) - (x - pi.x) * (pj.y - pi.y);
        if (l < 0.0) { winding = winding - 1; }
      }
    }

    j = i;
    i = i + 1u;
  }
  return winding != 0;
}

fn over(src:vec4f, dst:vec4f) -> vec4f {
  let ida = 1.0 - src.a;
  return vec4f(src.rgb + ida * dst.rgb, src.a + ida * dst.a);
}

@compute @workgroup_size(8,8,1)
fn main(@builtin(global_invocation_id) gid: vec3u) {
  if (gid.x >= uni.canvasW || gid.y >= uni.canvasH) { return; }
  let x = gid.x;
  let y = gid.y;

  let tX = x / uni.tileSize;
  let tY = y / uni.tileSize;
  let t  = tY * uni.tilesX + tX;
  let start = tileOffsets[t];
  let cnt   = tileCounts[t];

  var accum : vec4f = vec4f(0.0);
  let SS = uni.SS;
  let fSS = f32(SS);
  let invN = 1.0 / (fSS * fSS);

  // SSAA: (x + (sx+0.5)/SS, y + (sy+0.5)/SS)
  var sy : u32 = 0u;
  loop {
    if (sy >= SS) { break; }
    var sx : u32 = 0u;
    loop {
      if (sx >= SS) { break; }
      let fx = f32(x) + (f32(sx) + 0.5) / fSS;
      let fy = f32(y) + (f32(sy) + 0.5) / fSS;

      var col : vec4f = vec4f(0.0);
      var k : u32 = 0u;
      loop {
        if (k >= cnt) { break; }
        let sIdx = tileShapeIx[start + k];
        let sh = shapes[sIdx];
        var inside = false;
        if (sh.rule == 0u) {
          inside = point_in_evenodd(sh.vStart, sh.vCount, fx, fy);
        } else {
          inside = point_in_nonzero(sh.vStart, sh.vCount, fx, fy);
        }
        if (inside) {
          col = over(sh.color, col);
        }
        k = k + 1u;
      }
      accum = accum + col;
      sx = sx + 1u;
    }
    sy = sy + 1u;
  }

  let avg = accum * invN;
  // convert premul -> unpremul for storage (like CPU path)
  let A = clamp(avg.a, 0.0, 1.0);
  var rgb = vec3f(0.0);
  if (A > 0.000001) {
    rgb = clamp(avg.rgb / A, vec3f(0.0), vec3f(1.0));
  }
  textureStore(outputTex, vec2i(i32(x), i32(y)), vec4f(rgb, A));
}
`;

  const WGSL_BLIT = /* wgsl */`
@group(0) @binding(0) var srcTex : texture_2d<f32>;
@group(0) @binding(1) var samp   : sampler;

struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };

@vertex
fn vs(@builtin(vertex_index) vid: u32) -> VSOut {
  var p = array<vec2f,3>(
    vec2f(-1.0, -1.0),
    vec2f( 3.0, -1.0),
    vec2f(-1.0,  3.0)
  );
  var uv = array<vec2f,3>(
    vec2f(0.0, 0.0),
    vec2f(2.0, 0.0),
    vec2f(0.0, 2.0)
  );
  var o:VSOut;
  o.pos = vec4f(p[vid], 0.0, 1.0);
  o.uv  = uv[vid];
  return o;
}

@fragment
fn fs(i:VSOut) -> @location(0) vec4f {
  // level 0; premultiplied alpha mode is preserved by the canvas
  let c = textureSampleLevel(srcTex, samp, i.uv, 0.0);
  return c;
}
`;

  async function initWebGPUIfNeeded(width, height){
    if (!navigator.gpu) return null;
    if (!gpuAdapter) gpuAdapter = await navigator.gpu.requestAdapter();
    if (!gpuAdapter) return null;
    if (!gpuDevice) gpuDevice = await gpuAdapter.requestDevice();
    if (!gpuCtx) gpuCtx = cvGPU.getContext('webgpu');
    gpuFormat = navigator.gpu.getPreferredCanvasFormat();
    gpuCtx.configure({ device: gpuDevice, format: gpuFormat, alphaMode: 'premultiplied' });

    if (!gpuPipelines){
      const computeModule = gpuDevice.createShaderModule({ code: WGSL_COMPUTE });
      const blitModule    = gpuDevice.createShaderModule({ code: WGSL_BLIT });

      const computePipeline = gpuDevice.createComputePipeline({
        layout: 'auto',
        compute: { module: computeModule, entryPoint: 'main' }
      });

      const blitPipeline = gpuDevice.createRenderPipeline({
        layout: 'auto',
        vertex:   { module: blitModule, entryPoint: 'vs' },
        fragment: { module: blitModule, entryPoint: 'fs', targets: [{ format: gpuFormat }] }
      });

      const sampler = gpuDevice.createSampler({ magFilter:'nearest', minFilter:'nearest' });

      gpuPipelines = { computePipeline, blitPipeline, sampler };
    }

    if (!gpuResources || gpuResources.width!==width || gpuResources.height!==height){
      // recreate output texture & view
      const outputTex = gpuDevice.createTexture({
        size: { width, height },
        format: 'rgba8unorm',
        usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING
      });
      const outputView = outputTex.createView();
      gpuResources = { width, height, outputTex, outputView };
    }
    return { device: gpuDevice, ctx: gpuCtx, pipelines: gpuPipelines, res: gpuResources, format: gpuFormat };
  }

  // Upload arrays to GPU buffers
  function makeGPUBufferU32(data, usage){ return gpuDevice.createBuffer({ size: ((data.byteLength+3)>>2)<<2, usage, mappedAtCreation:true, }).mapAsync ? null : null; }
  function createBufferFromArray(arr, usage){
    const buf = gpuDevice.createBuffer({ size: (arr.byteLength+3)&~3, usage, mappedAtCreation: true });
    const map = buf.getMappedRange(); new (arr.constructor)(map).set(arr); buf.unmap(); return buf;
  }

  // ===============================
  // DRAW (CPU or WebGPU)
  // ===============================
  async function draw(){
    const tileSize=Number(tileInp.value);
    const nWorkers=Number(workersInp.value);
    const SS=Number(aaSel.value)|0;
    const [W,H]=[cvCPU.width,cvCPU.height];

    const t0=performance.now();
    const shapes=await buildShapesFromCode(codeEl.value);
    const shapesSafe = (shapes && shapes.length>0) ? shapes : (function(){
      const s=star(W*0.5,H*0.45,Math.min(W,H)*0.26,Math.min(W,H)*0.11,7);
      const arr=[{ verts: Float32Array.from(s.flat()), color: Uint8ClampedArray.from([88,156,255,220]), rule: fillRule }];
      for (const p of strokeToPolys(randomizeLines(), Number(strokeInp.value),
            { join:joinSel.value, cap:capSel.value, miterLimit:Number(miterInp.value) }))
        arr.push({ verts:p, color: Uint8ClampedArray.from([250,245,140,255]), rule:'evenodd' });
      return arr;
    })();

    const {tilesX,tilesY,tileCount,counts,offsets,tileShapeIndex}=binShapesIntoTiles(shapesSafe,tileSize, W, H);
    const t1=performance.now();

    // Report tiles
    tTiles.textContent = `${tilesX}×${Math.ceil(H/tileSize)} = ${tilesX*Math.ceil(H/tileSize)}`;
    tBuild.textContent=(t1-t0).toFixed(2)+' ms';

    const want = rendererSel.value;
    const hasGPU = !!navigator.gpu;
    const useGPU = (want==='webgpu') || (want==='auto' && hasGPU);

    if (useGPU){
      const gpu = await initWebGPUIfNeeded(W,H);
      if (!gpu){ console.warn('WebGPU unavailable, falling back to CPU.'); await drawCPU(); return; }
      cvGPU.style.display = ''; cvCPU.style.display = 'none';
      await drawWebGPU(shapesSafe, { tilesX, tilesY, tileSize, counts, offsets, tileShapeIndex, SS, W, H });
    } else {
      cvGPU.style.display = 'none'; cvCPU.style.display = '';
      await drawCPU(shapesSafe, { tilesX, tilesY, tileSize, counts, offsets, tileShapeIndex, SS, W, H, nWorkers });
    }
  }

  async function drawCPU(shapesSafe, info){
    const { tilesX, tileSize, counts, offsets, tileShapeIndex, SS, W, H, nWorkers } = info;

    const tileIds=new Uint32Array(counts.length); for(let i=0;i<counts.length;i++) tileIds[i]=i;
    const buckets=Array.from({length:nWorkers},()=>[]); for(let i=0;i<tileIds.length;i++) buckets[i%nWorkers].push(tileIds[i]);

    const workerURL=makeWorkerURL(); const workers=Array.from({length:nWorkers},()=>new Worker(workerURL));
    const jobs=buckets.map((tileIndices,wi)=>new Promise(resolve=>{
      const w=workers[wi];
      w.onmessage=(e)=>{ if(e.data&&e.data.kind==='tilesDone') resolve(e.data.results); };
      w.postMessage({ cmd:'renderTiles', tileSize, canvasW:W, canvasH:H, tilesX, tileIndices, offsets, counts, tileShapeIndex, shapes:shapesSafe, SS });
    }));

    const tR0=performance.now();
    const resultSets=await Promise.all(jobs);
    for(const w of workers) w.terminate();
    URL.revokeObjectURL(workerURL);

    ctx2D.clearRect(0,0,W,H);
    for(const results of resultSets){
      for(const r of results){
        const img=new ImageData(r.pixels, r.tileW, r.tileH);
        ctx2D.putImageData(img, r.tileX, r.tileY);
      }
    }
    const tR1=performance.now();
    tRaster.textContent=(tR1-tR0).toFixed(2)+' ms';
  }

  async function drawWebGPU(shapesSafe, info){
    const { tilesX, tileSize, counts, offsets, tileShapeIndex, SS, W, H } = info;
    const gpu = await initWebGPUIfNeeded(W,H); if (!gpu) return;
    const { device, ctx, pipelines, res } = gpu;
    const tR0 = performance.now();

    // Pack shapes -> vertices + metadata
    // Shapes are polygons (implicit closed). We'll store vertices as vec2f.
    let totalVerts = 0;
    for (const s of shapesSafe) totalVerts += (s.verts.length>>>1);
    const vBuf = new Float32Array(totalVerts*2);
    const shapeStride = (4*4 + 16); // calc not used – just for mind
    const shapeMeta = new Float32Array(shapesSafe.length * ( (4*4 + 16) / 4 )); // we'll compose as u32/u32/u32/u32 + vec4f
    // We'll actually create a Uint32Array view for first four u32s, then write color floats.
    const shapeU32 = new Uint32Array(shapeMeta.buffer);
    const shapeF32 = shapeMeta;

    let vCursor = 0, sIdx=0;
    for (const s of shapesSafe){
      const vCount = (s.verts.length>>>1);
      const vStart = vCursor;
      vBuf.set(s.verts, vCursor*2);
      vCursor += vCount;

      const baseU32 = sIdx*8;   // 8 u32 slots cover u32[4] + f32[4]
      const baseF32 = sIdx*8;

      shapeU32[baseU32+0] = vStart;
      shapeU32[baseU32+1] = vCount;
      shapeU32[baseU32+2] = (s.rule==='nonzero') ? 1 : 0;
      shapeU32[baseU32+3] = 0;

      const a = s.color[3]/255;
      const sr = (s.color[0]/255)*a;
      const sg = (s.color[1]/255)*a;
      const sb = (s.color[2]/255)*a;
      shapeF32[baseF32+4] = sr;
      shapeF32[baseF32+5] = sg;
      shapeF32[baseF32+6] = sb;
      shapeF32[baseF32+7] = a;

      sIdx++;
    }

    // Create/upload GPU buffers
    const uUniform = new Uint32Array([
      W, H, tileSize, tilesX, SS, 0,0,0
    ]);
    const bUniform       = createBufferFromArray(uUniform, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);
    const bShapes        = createBufferFromArray(shapeMeta, GPUBufferUsage.STORAGE);
    const bVertices      = createBufferFromArray(vBuf, GPUBufferUsage.STORAGE);
    const bTileOffsets   = createBufferFromArray(offsets, GPUBufferUsage.STORAGE);
    const bTileCounts    = createBufferFromArray(counts, GPUBufferUsage.STORAGE);
    const bTileShapeIx   = createBufferFromArray(tileShapeIndex, GPUBufferUsage.STORAGE);

    const bind0 = device.createBindGroup({
      layout: pipelines.computePipeline.getBindGroupLayout(0),
      entries: [
        { binding:0, resource:{ buffer:bUniform } },
        { binding:1, resource:{ buffer:bShapes } },
        { binding:2, resource:{ buffer:bVertices } },
        { binding:3, resource:{ buffer:bTileOffsets } },
        { binding:4, resource:{ buffer:bTileCounts } },
        { binding:5, resource:{ buffer:bTileShapeIx } },
        { binding:6, resource: res.outputView }
      ]
    });

    // Compute pass (one thread per pixel)
    const encoder = device.createCommandEncoder();
    const cpass   = encoder.beginComputePass();
    cpass.setPipeline(pipelines.computePipeline);
    cpass.setBindGroup(0, bind0);
    const wgSize = 8;
    cpass.dispatchWorkgroups(Math.ceil(W/wgSize), Math.ceil(H/wgSize));
    cpass.end();

    // Blit pass to canvas
    const view = ctx.getCurrentTexture().createView();
    const rpass = encoder.beginRenderPass({
      colorAttachments: [{ view, loadOp:'clear', clearValue:{r:0,g:0,b:0,a:1}, storeOp:'store' }]
    });
    const blitBG = device.createBindGroup({
      layout: pipelines.blitPipeline.getBindGroupLayout(0),
      entries: [
        { binding:0, resource: res.outputView },
        { binding:1, resource: pipelines.sampler }
      ]
    });
    rpass.setPipeline(pipelines.blitPipeline);
    rpass.setBindGroup(0, blitBG);
    rpass.draw(3,1,0,0);
    rpass.end();

    device.queue.submit([encoder.finish()]);
    await device.queue.onSubmittedWorkDone();

    const tR1 = performance.now();
    tRaster.textContent=(tR1-tR0).toFixed(2)+' ms';
  }

  // ===============================
  // INIT
  // ===============================
  function initialSize(){
    const [w,h]=sizeSel.value.split('x').map(Number);
    setCanvasSize(w,h);
    selectCanvasForRenderer();
  }
  initialSize();
  randomizeLines();
  draw();
})();
</script>
</body>
</html>
